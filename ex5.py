import random
import timeit
import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt

def linear_search(n, l):
    for i in range(len(l)):
        if l[i] == n:
            return True
    return False

def binary_search(n, l):
    low, high = 0, len(l) - 1
    while low <= high:
        mid = (low + high) // 2
        if l[mid] == n:
            return True
        elif l[mid] < n:
            low = mid + 1
        else:
            high = mid - 1
    return False

def fit_linear_func(x, a, b):
    return a * x + b

#for binary search
def fit_logarithmic_func(x, a, b):
    return a * np.log(x) + b

list_lengths = [1000, 2000, 4000, 8000, 16000, 32000]
search_type = [linear_search, binary_search]
#code of lecture 07 modified by chatgpt
avg_times = []
for search_function in search_type:
    avg_times_per_function = []
    
    for list_length in list_lengths:
        numbers = [x for x in range(list_length)]
        avg_time_per_length = []

        for _ in range(1000):
            random_element = random.choice(numbers)
            time_taken = timeit.timeit(lambda: search_function(random_element, numbers), number=100)
            avg_time_per_length.append(time_taken / 100)
            #avg = sum(avg_time_per_length) / len(avg_time_per_length)
        #print(f"Average time for {search_function.__name__} on a list of length {list_length}: {avg}")
        avg_times_per_function.append(np.mean(avg_time_per_length))
        #print(f"Average time for {search_function.__name__} on a list of length {list_length}: {avg_time_per_length}")

    avg_times.append(avg_times_per_function)
    
# Linear Fit
params_linear = [curve_fit(fit_linear_func, list_lengths, avg_times[i])[0] for i in range(len(search_type))]

# log Fit for Binary Search
params_log = [curve_fit(fit_logarithmic_func, list_lengths, avg_times[i])[0] for i in range(len(search_type))]

#end of the code generated by chatgpt

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1) 
plt.scatter(list_lengths, avg_times[0], label="Linear Search")
plt.plot(list_lengths, fit_linear_func(np.array(list_lengths), *params_linear[0]), label="Linear Fit (Linear Search)")

plt.scatter(list_lengths, avg_times[1], label="Binary Search")
plt.plot(list_lengths, fit_logarithmic_func(np.array(list_lengths), *params_log[0]), label="Quadratic Fit (Binary Search)")

plt.legend()
plt.xlabel('Length')
plt.ylabel('Average Time')
plt.title('Performance Comparison')

#log
plt.subplot(1, 2, 2)
plt.scatter(list_lengths, avg_times[0], label="Linear Search")
plt.plot(list_lengths, fit_linear_func(np.array(list_lengths), *params_linear[0]), label="Linear Fit (Linear Search)")

plt.scatter(list_lengths, avg_times[1], label="Binary Search")
plt.plot(list_lengths, fit_logarithmic_func(np.array(list_lengths), *params_log[0]), label="Quadratic Fit (Binary Search)")

plt.legend()
plt.xlabel('Length')
plt.ylabel('Average Time')
plt.yscale('log')  
plt.title('Performance Comparison (Log Scale)')
plt.tight_layout()  
plt.show()

#QUESTION 4
#Linear search: the type of function generated is linear, ax + b, where 'a' represents the sizes of the list and 'b'the time taken to search the key value.
#The obtaiend plot shows a positive slope, indicating that as the size of the list increaeses, the time taken to search the desired value also increases.

#For binary search, the type of function generated is a logarithmic function, alog(x) + b, 
# where 'a' is the logarithm of the sizes of the list and 'b' is the time taken to search the key value. 
# We used a logarithmic scale to plot the graph to be able to analyzethe results. 
#After making these changes, we were able to confirm that the time taken to search the list increases very slowly as the size increases 
    

    
